// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: iTCH.proto

#ifndef PROTOBUF_iTCH_2eproto__INCLUDED
#define PROTOBUF_iTCH_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace iTCH {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_iTCH_2eproto();
void protobuf_AssignDesc_iTCH_2eproto();
void protobuf_ShutdownFile_iTCH_2eproto();

class Hello;
class Envelope;
class ServerNotification;
class ClientRequest;
class ClientRequest_Value;
class Track;
class ServerResponse;
class ServerResponse_Value;

enum Envelope_Type {
  Envelope_Type_SERVERNOTIFICATION = 0,
  Envelope_Type_CLIENTREQUEST = 1,
  Envelope_Type_SERVERRESPONSE = 2
};
bool Envelope_Type_IsValid(int value);
const Envelope_Type Envelope_Type_Type_MIN = Envelope_Type_SERVERNOTIFICATION;
const Envelope_Type Envelope_Type_Type_MAX = Envelope_Type_SERVERRESPONSE;
const int Envelope_Type_Type_ARRAYSIZE = Envelope_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Envelope_Type_descriptor();
inline const ::std::string& Envelope_Type_Name(Envelope_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Envelope_Type_descriptor(), value);
}
inline bool Envelope_Type_Parse(
    const ::std::string& name, Envelope_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Envelope_Type>(
    Envelope_Type_descriptor(), name, value);
}
enum ServerNotification_Type {
  ServerNotification_Type_VOLUMECHANGED = 0,
  ServerNotification_Type_PLAYINGSTARTED = 1,
  ServerNotification_Type_PLAYINGSTOPPED = 2,
  ServerNotification_Type_TRACKINFOCHANGED = 3
};
bool ServerNotification_Type_IsValid(int value);
const ServerNotification_Type ServerNotification_Type_Type_MIN = ServerNotification_Type_VOLUMECHANGED;
const ServerNotification_Type ServerNotification_Type_Type_MAX = ServerNotification_Type_TRACKINFOCHANGED;
const int ServerNotification_Type_Type_ARRAYSIZE = ServerNotification_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerNotification_Type_descriptor();
inline const ::std::string& ServerNotification_Type_Name(ServerNotification_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerNotification_Type_descriptor(), value);
}
inline bool ServerNotification_Type_Parse(
    const ::std::string& name, ServerNotification_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerNotification_Type>(
    ServerNotification_Type_descriptor(), name, value);
}
enum ClientRequest_Value_Type {
  ClientRequest_Value_Type_VOLUME = 0,
  ClientRequest_Value_Type_MUTE = 1,
  ClientRequest_Value_Type_POSITION = 2
};
bool ClientRequest_Value_Type_IsValid(int value);
const ClientRequest_Value_Type ClientRequest_Value_Type_Type_MIN = ClientRequest_Value_Type_VOLUME;
const ClientRequest_Value_Type ClientRequest_Value_Type_Type_MAX = ClientRequest_Value_Type_POSITION;
const int ClientRequest_Value_Type_Type_ARRAYSIZE = ClientRequest_Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientRequest_Value_Type_descriptor();
inline const ::std::string& ClientRequest_Value_Type_Name(ClientRequest_Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientRequest_Value_Type_descriptor(), value);
}
inline bool ClientRequest_Value_Type_Parse(
    const ::std::string& name, ClientRequest_Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientRequest_Value_Type>(
    ClientRequest_Value_Type_descriptor(), name, value);
}
enum ClientRequest_Type {
  ClientRequest_Type_BACKTRACK = 0,
  ClientRequest_Type_FASTFORWARD = 1,
  ClientRequest_Type_NEXTTRACK = 2,
  ClientRequest_Type_PAUSE = 3,
  ClientRequest_Type_PLAY = 4,
  ClientRequest_Type_PLAYPAUSE = 5,
  ClientRequest_Type_PREVIOUSTRACK = 6,
  ClientRequest_Type_RESUME = 7,
  ClientRequest_Type_REWIND = 8,
  ClientRequest_Type_STOP = 9,
  ClientRequest_Type_GET_SOUNDVOLUME = 10,
  ClientRequest_Type_PUT_SOUNDVOLUME = 11,
  ClientRequest_Type_GET_MUTE = 12,
  ClientRequest_Type_PUT_MUTE = 13,
  ClientRequest_Type_GET_PLAYERPOSITION = 14,
  ClientRequest_Type_PUT_PLAYERPOSITION = 15,
  ClientRequest_Type_GET_PLAYERSTATE = 16,
  ClientRequest_Type_GET_CURRENTTRACK = 17,
  ClientRequest_Type_GET_CURRENTPLAYLIST = 18
};
bool ClientRequest_Type_IsValid(int value);
const ClientRequest_Type ClientRequest_Type_Type_MIN = ClientRequest_Type_BACKTRACK;
const ClientRequest_Type ClientRequest_Type_Type_MAX = ClientRequest_Type_GET_CURRENTPLAYLIST;
const int ClientRequest_Type_Type_ARRAYSIZE = ClientRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientRequest_Type_descriptor();
inline const ::std::string& ClientRequest_Type_Name(ClientRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientRequest_Type_descriptor(), value);
}
inline bool ClientRequest_Type_Parse(
    const ::std::string& name, ClientRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientRequest_Type>(
    ClientRequest_Type_descriptor(), name, value);
}
enum ServerResponse_Value_Type {
  ServerResponse_Value_Type_VOLUME = 0,
  ServerResponse_Value_Type_MUTE = 1,
  ServerResponse_Value_Type_POSITION = 2,
  ServerResponse_Value_Type_STATE = 3,
  ServerResponse_Value_Type_TRACK = 4,
  ServerResponse_Value_Type_PLAYLIST = 5
};
bool ServerResponse_Value_Type_IsValid(int value);
const ServerResponse_Value_Type ServerResponse_Value_Type_Type_MIN = ServerResponse_Value_Type_VOLUME;
const ServerResponse_Value_Type ServerResponse_Value_Type_Type_MAX = ServerResponse_Value_Type_PLAYLIST;
const int ServerResponse_Value_Type_Type_ARRAYSIZE = ServerResponse_Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerResponse_Value_Type_descriptor();
inline const ::std::string& ServerResponse_Value_Type_Name(ServerResponse_Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerResponse_Value_Type_descriptor(), value);
}
inline bool ServerResponse_Value_Type_Parse(
    const ::std::string& name, ServerResponse_Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerResponse_Value_Type>(
    ServerResponse_Value_Type_descriptor(), name, value);
}
enum Version {
  PROTOCOL_VERSION = 0
};
bool Version_IsValid(int value);
const Version Version_MIN = PROTOCOL_VERSION;
const Version Version_MAX = PROTOCOL_VERSION;
const int Version_ARRAYSIZE = Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* Version_descriptor();
inline const ::std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    Version_descriptor(), value);
}
inline bool Version_Parse(
    const ::std::string& name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
    Version_descriptor(), name, value);
}
enum PlayerState {
  UNKNOWN = 0,
  STOPPED = 1,
  PLAYING = 2,
  FASTFORWARD = 3,
  REWIND = 4
};
bool PlayerState_IsValid(int value);
const PlayerState PlayerState_MIN = UNKNOWN;
const PlayerState PlayerState_MAX = REWIND;
const int PlayerState_ARRAYSIZE = PlayerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerState_descriptor();
inline const ::std::string& PlayerState_Name(PlayerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerState_descriptor(), value);
}
inline bool PlayerState_Parse(
    const ::std::string& name, PlayerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerState>(
    PlayerState_descriptor(), name, value);
}
// ===================================================================

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();
  
  Hello(const Hello& from);
  
  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();
  
  void Swap(Hello* other);
  
  // implements Message ----------------------------------------------
  
  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.Version version = 1 [default = PROTOCOL_VERSION];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline iTCH::Version version() const;
  inline void set_version(iTCH::Version value);
  
  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  
  // optional string program_name = 3;
  inline bool has_program_name() const;
  inline void clear_program_name();
  static const int kProgramNameFieldNumber = 3;
  inline const ::std::string& program_name() const;
  inline void set_program_name(const ::std::string& value);
  inline void set_program_name(const char* value);
  inline void set_program_name(const char* value, size_t size);
  inline ::std::string* mutable_program_name();
  inline ::std::string* release_program_name();
  
  // optional string program_version = 4;
  inline bool has_program_version() const;
  inline void clear_program_version();
  static const int kProgramVersionFieldNumber = 4;
  inline const ::std::string& program_version() const;
  inline void set_program_version(const ::std::string& value);
  inline void set_program_version(const char* value);
  inline void set_program_version(const char* value, size_t size);
  inline ::std::string* mutable_program_version();
  inline ::std::string* release_program_version();
  
  // @@protoc_insertion_point(class_scope:iTCH.Hello)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_program_name();
  inline void clear_has_program_name();
  inline void set_has_program_version();
  inline void clear_has_program_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hostname_;
  ::std::string* program_name_;
  ::std::string* program_version_;
  int version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();
  
  Envelope(const Envelope& from);
  
  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();
  
  void Swap(Envelope* other);
  
  // implements Message ----------------------------------------------
  
  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Envelope_Type Type;
  static const Type SERVERNOTIFICATION = Envelope_Type_SERVERNOTIFICATION;
  static const Type CLIENTREQUEST = Envelope_Type_CLIENTREQUEST;
  static const Type SERVERRESPONSE = Envelope_Type_SERVERRESPONSE;
  static inline bool Type_IsValid(int value) {
    return Envelope_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Envelope_Type_Type_MIN;
  static const Type Type_MAX =
    Envelope_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Envelope_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Envelope_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Envelope_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Envelope_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.Envelope.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::iTCH::Envelope_Type type() const;
  inline void set_type(::iTCH::Envelope_Type value);
  
  // optional .iTCH.ServerNotification notification = 2;
  inline bool has_notification() const;
  inline void clear_notification();
  static const int kNotificationFieldNumber = 2;
  inline const ::iTCH::ServerNotification& notification() const;
  inline ::iTCH::ServerNotification* mutable_notification();
  inline ::iTCH::ServerNotification* release_notification();
  
  // optional .iTCH.ClientRequest request = 3;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 3;
  inline const ::iTCH::ClientRequest& request() const;
  inline ::iTCH::ClientRequest* mutable_request();
  inline ::iTCH::ClientRequest* release_request();
  
  // optional .iTCH.ServerResponse response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline const ::iTCH::ServerResponse& response() const;
  inline ::iTCH::ServerResponse* mutable_response();
  inline ::iTCH::ServerResponse* release_response();
  
  // @@protoc_insertion_point(class_scope:iTCH.Envelope)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_notification();
  inline void clear_has_notification();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::iTCH::ServerNotification* notification_;
  ::iTCH::ClientRequest* request_;
  ::iTCH::ServerResponse* response_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class ServerNotification : public ::google::protobuf::Message {
 public:
  ServerNotification();
  virtual ~ServerNotification();
  
  ServerNotification(const ServerNotification& from);
  
  inline ServerNotification& operator=(const ServerNotification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerNotification& default_instance();
  
  void Swap(ServerNotification* other);
  
  // implements Message ----------------------------------------------
  
  ServerNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerNotification& from);
  void MergeFrom(const ServerNotification& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerNotification_Type Type;
  static const Type VOLUMECHANGED = ServerNotification_Type_VOLUMECHANGED;
  static const Type PLAYINGSTARTED = ServerNotification_Type_PLAYINGSTARTED;
  static const Type PLAYINGSTOPPED = ServerNotification_Type_PLAYINGSTOPPED;
  static const Type TRACKINFOCHANGED = ServerNotification_Type_TRACKINFOCHANGED;
  static inline bool Type_IsValid(int value) {
    return ServerNotification_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ServerNotification_Type_Type_MIN;
  static const Type Type_MAX =
    ServerNotification_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ServerNotification_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ServerNotification_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ServerNotification_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ServerNotification_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.ServerNotification.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::iTCH::ServerNotification_Type type() const;
  inline void set_type(::iTCH::ServerNotification_Type value);
  
  // @@protoc_insertion_point(class_scope:iTCH.ServerNotification)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static ServerNotification* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_Value : public ::google::protobuf::Message {
 public:
  ClientRequest_Value();
  virtual ~ClientRequest_Value();
  
  ClientRequest_Value(const ClientRequest_Value& from);
  
  inline ClientRequest_Value& operator=(const ClientRequest_Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_Value& default_instance();
  
  void Swap(ClientRequest_Value* other);
  
  // implements Message ----------------------------------------------
  
  ClientRequest_Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_Value& from);
  void MergeFrom(const ClientRequest_Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientRequest_Value_Type Type;
  static const Type VOLUME = ClientRequest_Value_Type_VOLUME;
  static const Type MUTE = ClientRequest_Value_Type_MUTE;
  static const Type POSITION = ClientRequest_Value_Type_POSITION;
  static inline bool Type_IsValid(int value) {
    return ClientRequest_Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientRequest_Value_Type_Type_MIN;
  static const Type Type_MAX =
    ClientRequest_Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientRequest_Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientRequest_Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientRequest_Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientRequest_Value_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.ClientRequest.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::iTCH::ClientRequest_Value_Type type() const;
  inline void set_type(::iTCH::ClientRequest_Value_Type value);
  
  // optional uint32 volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline ::google::protobuf::uint32 volume() const;
  inline void set_volume(::google::protobuf::uint32 value);
  
  // optional bool mute = 3;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 3;
  inline bool mute() const;
  inline void set_mute(bool value);
  
  // optional uint32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:iTCH.ClientRequest.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_mute();
  inline void clear_has_mute();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::uint32 volume_;
  bool mute_;
  ::google::protobuf::uint32 position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static ClientRequest_Value* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message {
 public:
  ClientRequest();
  virtual ~ClientRequest();
  
  ClientRequest(const ClientRequest& from);
  
  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();
  
  void Swap(ClientRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientRequest_Value Value;
  
  typedef ClientRequest_Type Type;
  static const Type BACKTRACK = ClientRequest_Type_BACKTRACK;
  static const Type FASTFORWARD = ClientRequest_Type_FASTFORWARD;
  static const Type NEXTTRACK = ClientRequest_Type_NEXTTRACK;
  static const Type PAUSE = ClientRequest_Type_PAUSE;
  static const Type PLAY = ClientRequest_Type_PLAY;
  static const Type PLAYPAUSE = ClientRequest_Type_PLAYPAUSE;
  static const Type PREVIOUSTRACK = ClientRequest_Type_PREVIOUSTRACK;
  static const Type RESUME = ClientRequest_Type_RESUME;
  static const Type REWIND = ClientRequest_Type_REWIND;
  static const Type STOP = ClientRequest_Type_STOP;
  static const Type GET_SOUNDVOLUME = ClientRequest_Type_GET_SOUNDVOLUME;
  static const Type PUT_SOUNDVOLUME = ClientRequest_Type_PUT_SOUNDVOLUME;
  static const Type GET_MUTE = ClientRequest_Type_GET_MUTE;
  static const Type PUT_MUTE = ClientRequest_Type_PUT_MUTE;
  static const Type GET_PLAYERPOSITION = ClientRequest_Type_GET_PLAYERPOSITION;
  static const Type PUT_PLAYERPOSITION = ClientRequest_Type_PUT_PLAYERPOSITION;
  static const Type GET_PLAYERSTATE = ClientRequest_Type_GET_PLAYERSTATE;
  static const Type GET_CURRENTTRACK = ClientRequest_Type_GET_CURRENTTRACK;
  static const Type GET_CURRENTPLAYLIST = ClientRequest_Type_GET_CURRENTPLAYLIST;
  static inline bool Type_IsValid(int value) {
    return ClientRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientRequest_Type_Type_MIN;
  static const Type Type_MAX =
    ClientRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientRequest_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 seqid = 1;
  inline bool has_seqid() const;
  inline void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  inline ::google::protobuf::uint32 seqid() const;
  inline void set_seqid(::google::protobuf::uint32 value);
  
  // required .iTCH.ClientRequest.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::iTCH::ClientRequest_Type type() const;
  inline void set_type(::iTCH::ClientRequest_Type value);
  
  // optional .iTCH.ClientRequest.Value value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::iTCH::ClientRequest_Value& value() const;
  inline ::iTCH::ClientRequest_Value* mutable_value();
  inline ::iTCH::ClientRequest_Value* release_value();
  
  // @@protoc_insertion_point(class_scope:iTCH.ClientRequest)
 private:
  inline void set_has_seqid();
  inline void clear_has_seqid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 seqid_;
  int type_;
  ::iTCH::ClientRequest_Value* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static ClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class Track : public ::google::protobuf::Message {
 public:
  Track();
  virtual ~Track();
  
  Track(const Track& from);
  
  inline Track& operator=(const Track& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Track& default_instance();
  
  void Swap(Track* other);
  
  // implements Message ----------------------------------------------
  
  Track* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Track& from);
  void MergeFrom(const Track& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string artist = 2;
  inline bool has_artist() const;
  inline void clear_artist();
  static const int kArtistFieldNumber = 2;
  inline const ::std::string& artist() const;
  inline void set_artist(const ::std::string& value);
  inline void set_artist(const char* value);
  inline void set_artist(const char* value, size_t size);
  inline ::std::string* mutable_artist();
  inline ::std::string* release_artist();
  
  // required string album = 3;
  inline bool has_album() const;
  inline void clear_album();
  static const int kAlbumFieldNumber = 3;
  inline const ::std::string& album() const;
  inline void set_album(const ::std::string& value);
  inline void set_album(const char* value);
  inline void set_album(const char* value, size_t size);
  inline ::std::string* mutable_album();
  inline ::std::string* release_album();
  
  // required uint32 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);
  
  // required string genre = 5;
  inline bool has_genre() const;
  inline void clear_genre();
  static const int kGenreFieldNumber = 5;
  inline const ::std::string& genre() const;
  inline void set_genre(const ::std::string& value);
  inline void set_genre(const char* value);
  inline void set_genre(const char* value, size_t size);
  inline ::std::string* mutable_genre();
  inline ::std::string* release_genre();
  
  // required uint32 year = 6;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 6;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);
  
  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);
  
  // optional uint32 sample_rate = 8;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 8;
  inline ::google::protobuf::uint32 sample_rate() const;
  inline void set_sample_rate(::google::protobuf::uint32 value);
  
  // optional string comment = 9;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 9;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // optional string kind = 10;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 10;
  inline const ::std::string& kind() const;
  inline void set_kind(const ::std::string& value);
  inline void set_kind(const char* value);
  inline void set_kind(const char* value, size_t size);
  inline ::std::string* mutable_kind();
  inline ::std::string* release_kind();
  
  // @@protoc_insertion_point(class_scope:iTCH.Track)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_artist();
  inline void clear_has_artist();
  inline void set_has_album();
  inline void clear_has_album();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_genre();
  inline void clear_has_genre();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_kind();
  inline void clear_has_kind();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* artist_;
  ::std::string* album_;
  ::std::string* genre_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::uint32 sample_rate_;
  ::std::string* comment_;
  ::std::string* kind_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static Track* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse_Value : public ::google::protobuf::Message {
 public:
  ServerResponse_Value();
  virtual ~ServerResponse_Value();
  
  ServerResponse_Value(const ServerResponse_Value& from);
  
  inline ServerResponse_Value& operator=(const ServerResponse_Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse_Value& default_instance();
  
  void Swap(ServerResponse_Value* other);
  
  // implements Message ----------------------------------------------
  
  ServerResponse_Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse_Value& from);
  void MergeFrom(const ServerResponse_Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerResponse_Value_Type Type;
  static const Type VOLUME = ServerResponse_Value_Type_VOLUME;
  static const Type MUTE = ServerResponse_Value_Type_MUTE;
  static const Type POSITION = ServerResponse_Value_Type_POSITION;
  static const Type STATE = ServerResponse_Value_Type_STATE;
  static const Type TRACK = ServerResponse_Value_Type_TRACK;
  static const Type PLAYLIST = ServerResponse_Value_Type_PLAYLIST;
  static inline bool Type_IsValid(int value) {
    return ServerResponse_Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ServerResponse_Value_Type_Type_MIN;
  static const Type Type_MAX =
    ServerResponse_Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ServerResponse_Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ServerResponse_Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ServerResponse_Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ServerResponse_Value_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.ServerResponse.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::iTCH::ServerResponse_Value_Type type() const;
  inline void set_type(::iTCH::ServerResponse_Value_Type value);
  
  // optional uint32 volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline ::google::protobuf::uint32 volume() const;
  inline void set_volume(::google::protobuf::uint32 value);
  
  // optional bool mute = 3;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 3;
  inline bool mute() const;
  inline void set_mute(bool value);
  
  // optional uint32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);
  
  // optional .iTCH.PlayerState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline iTCH::PlayerState state() const;
  inline void set_state(iTCH::PlayerState value);
  
  // optional .iTCH.Track track = 6;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 6;
  inline const ::iTCH::Track& track() const;
  inline ::iTCH::Track* mutable_track();
  inline ::iTCH::Track* release_track();
  
  // repeated .iTCH.Track playlist = 7;
  inline int playlist_size() const;
  inline void clear_playlist();
  static const int kPlaylistFieldNumber = 7;
  inline const ::iTCH::Track& playlist(int index) const;
  inline ::iTCH::Track* mutable_playlist(int index);
  inline ::iTCH::Track* add_playlist();
  inline const ::google::protobuf::RepeatedPtrField< ::iTCH::Track >&
      playlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::iTCH::Track >*
      mutable_playlist();
  
  // @@protoc_insertion_point(class_scope:iTCH.ServerResponse.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_mute();
  inline void clear_has_mute();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_track();
  inline void clear_has_track();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::uint32 volume_;
  bool mute_;
  ::google::protobuf::uint32 position_;
  ::iTCH::Track* track_;
  ::google::protobuf::RepeatedPtrField< ::iTCH::Track > playlist_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static ServerResponse_Value* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message {
 public:
  ServerResponse();
  virtual ~ServerResponse();
  
  ServerResponse(const ServerResponse& from);
  
  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();
  
  void Swap(ServerResponse* other);
  
  // implements Message ----------------------------------------------
  
  ServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerResponse_Value Value;
  
  // accessors -------------------------------------------------------
  
  // required uint32 seqid = 1 [default = 0];
  inline bool has_seqid() const;
  inline void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  inline ::google::protobuf::uint32 seqid() const;
  inline void set_seqid(::google::protobuf::uint32 value);
  
  // required bool success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  
  // optional .iTCH.ServerResponse.Value value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::iTCH::ServerResponse_Value& value() const;
  inline ::iTCH::ServerResponse_Value* mutable_value();
  inline ::iTCH::ServerResponse_Value* release_value();
  
  // @@protoc_insertion_point(class_scope:iTCH.ServerResponse)
 private:
  inline void set_has_seqid();
  inline void clear_has_seqid();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 seqid_;
  bool success_;
  ::std::string* error_message_;
  ::iTCH::ServerResponse_Value* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  void InitAsDefaultInstance();
  static ServerResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Hello

// required .iTCH.Version version = 1 [default = PROTOCOL_VERSION];
inline bool Hello::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline iTCH::Version Hello::version() const {
  return static_cast< iTCH::Version >(version_);
}
inline void Hello::set_version(iTCH::Version value) {
  GOOGLE_DCHECK(iTCH::Version_IsValid(value));
  set_has_version();
  version_ = value;
}

// optional string hostname = 2;
inline bool Hello::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hello::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hello::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hello::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Hello::hostname() const {
  return *hostname_;
}
inline void Hello::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Hello::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Hello::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Hello::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string program_name = 3;
inline bool Hello::has_program_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hello::set_has_program_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hello::clear_has_program_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hello::clear_program_name() {
  if (program_name_ != &::google::protobuf::internal::kEmptyString) {
    program_name_->clear();
  }
  clear_has_program_name();
}
inline const ::std::string& Hello::program_name() const {
  return *program_name_;
}
inline void Hello::set_program_name(const ::std::string& value) {
  set_has_program_name();
  if (program_name_ == &::google::protobuf::internal::kEmptyString) {
    program_name_ = new ::std::string;
  }
  program_name_->assign(value);
}
inline void Hello::set_program_name(const char* value) {
  set_has_program_name();
  if (program_name_ == &::google::protobuf::internal::kEmptyString) {
    program_name_ = new ::std::string;
  }
  program_name_->assign(value);
}
inline void Hello::set_program_name(const char* value, size_t size) {
  set_has_program_name();
  if (program_name_ == &::google::protobuf::internal::kEmptyString) {
    program_name_ = new ::std::string;
  }
  program_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_program_name() {
  set_has_program_name();
  if (program_name_ == &::google::protobuf::internal::kEmptyString) {
    program_name_ = new ::std::string;
  }
  return program_name_;
}
inline ::std::string* Hello::release_program_name() {
  clear_has_program_name();
  if (program_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = program_name_;
    program_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string program_version = 4;
inline bool Hello::has_program_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hello::set_has_program_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hello::clear_has_program_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hello::clear_program_version() {
  if (program_version_ != &::google::protobuf::internal::kEmptyString) {
    program_version_->clear();
  }
  clear_has_program_version();
}
inline const ::std::string& Hello::program_version() const {
  return *program_version_;
}
inline void Hello::set_program_version(const ::std::string& value) {
  set_has_program_version();
  if (program_version_ == &::google::protobuf::internal::kEmptyString) {
    program_version_ = new ::std::string;
  }
  program_version_->assign(value);
}
inline void Hello::set_program_version(const char* value) {
  set_has_program_version();
  if (program_version_ == &::google::protobuf::internal::kEmptyString) {
    program_version_ = new ::std::string;
  }
  program_version_->assign(value);
}
inline void Hello::set_program_version(const char* value, size_t size) {
  set_has_program_version();
  if (program_version_ == &::google::protobuf::internal::kEmptyString) {
    program_version_ = new ::std::string;
  }
  program_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_program_version() {
  set_has_program_version();
  if (program_version_ == &::google::protobuf::internal::kEmptyString) {
    program_version_ = new ::std::string;
  }
  return program_version_;
}
inline ::std::string* Hello::release_program_version() {
  clear_has_program_version();
  if (program_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = program_version_;
    program_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Envelope

// required .iTCH.Envelope.Type type = 1;
inline bool Envelope::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::iTCH::Envelope_Type Envelope::type() const {
  return static_cast< ::iTCH::Envelope_Type >(type_);
}
inline void Envelope::set_type(::iTCH::Envelope_Type value) {
  GOOGLE_DCHECK(::iTCH::Envelope_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .iTCH.ServerNotification notification = 2;
inline bool Envelope::has_notification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_notification() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_notification() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_notification() {
  if (notification_ != NULL) notification_->::iTCH::ServerNotification::Clear();
  clear_has_notification();
}
inline const ::iTCH::ServerNotification& Envelope::notification() const {
  return notification_ != NULL ? *notification_ : *default_instance_->notification_;
}
inline ::iTCH::ServerNotification* Envelope::mutable_notification() {
  set_has_notification();
  if (notification_ == NULL) notification_ = new ::iTCH::ServerNotification;
  return notification_;
}
inline ::iTCH::ServerNotification* Envelope::release_notification() {
  clear_has_notification();
  ::iTCH::ServerNotification* temp = notification_;
  notification_ = NULL;
  return temp;
}

// optional .iTCH.ClientRequest request = 3;
inline bool Envelope::has_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_request() {
  if (request_ != NULL) request_->::iTCH::ClientRequest::Clear();
  clear_has_request();
}
inline const ::iTCH::ClientRequest& Envelope::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::iTCH::ClientRequest* Envelope::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::iTCH::ClientRequest;
  return request_;
}
inline ::iTCH::ClientRequest* Envelope::release_request() {
  clear_has_request();
  ::iTCH::ClientRequest* temp = request_;
  request_ = NULL;
  return temp;
}

// optional .iTCH.ServerResponse response = 4;
inline bool Envelope::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_response() {
  if (response_ != NULL) response_->::iTCH::ServerResponse::Clear();
  clear_has_response();
}
inline const ::iTCH::ServerResponse& Envelope::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::iTCH::ServerResponse* Envelope::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::iTCH::ServerResponse;
  return response_;
}
inline ::iTCH::ServerResponse* Envelope::release_response() {
  clear_has_response();
  ::iTCH::ServerResponse* temp = response_;
  response_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ServerNotification

// required .iTCH.ServerNotification.Type type = 1;
inline bool ServerNotification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerNotification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerNotification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerNotification::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::iTCH::ServerNotification_Type ServerNotification::type() const {
  return static_cast< ::iTCH::ServerNotification_Type >(type_);
}
inline void ServerNotification::set_type(::iTCH::ServerNotification_Type value) {
  GOOGLE_DCHECK(::iTCH::ServerNotification_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_Value

// required .iTCH.ClientRequest.Value.Type type = 1;
inline bool ClientRequest_Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::iTCH::ClientRequest_Value_Type ClientRequest_Value::type() const {
  return static_cast< ::iTCH::ClientRequest_Value_Type >(type_);
}
inline void ClientRequest_Value::set_type(::iTCH::ClientRequest_Value_Type value) {
  GOOGLE_DCHECK(::iTCH::ClientRequest_Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 volume = 2;
inline bool ClientRequest_Value::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest_Value::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest_Value::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest_Value::clear_volume() {
  volume_ = 0u;
  clear_has_volume();
}
inline ::google::protobuf::uint32 ClientRequest_Value::volume() const {
  return volume_;
}
inline void ClientRequest_Value::set_volume(::google::protobuf::uint32 value) {
  set_has_volume();
  volume_ = value;
}

// optional bool mute = 3;
inline bool ClientRequest_Value::has_mute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest_Value::set_has_mute() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest_Value::clear_has_mute() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest_Value::clear_mute() {
  mute_ = false;
  clear_has_mute();
}
inline bool ClientRequest_Value::mute() const {
  return mute_;
}
inline void ClientRequest_Value::set_mute(bool value) {
  set_has_mute();
  mute_ = value;
}

// optional uint32 position = 4;
inline bool ClientRequest_Value::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientRequest_Value::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientRequest_Value::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientRequest_Value::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 ClientRequest_Value::position() const {
  return position_;
}
inline void ClientRequest_Value::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// -------------------------------------------------------------------

// ClientRequest

// required uint32 seqid = 1;
inline bool ClientRequest::has_seqid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest::set_has_seqid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest::clear_has_seqid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest::clear_seqid() {
  seqid_ = 0u;
  clear_has_seqid();
}
inline ::google::protobuf::uint32 ClientRequest::seqid() const {
  return seqid_;
}
inline void ClientRequest::set_seqid(::google::protobuf::uint32 value) {
  set_has_seqid();
  seqid_ = value;
}

// required .iTCH.ClientRequest.Type type = 2;
inline bool ClientRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::iTCH::ClientRequest_Type ClientRequest::type() const {
  return static_cast< ::iTCH::ClientRequest_Type >(type_);
}
inline void ClientRequest::set_type(::iTCH::ClientRequest_Type value) {
  GOOGLE_DCHECK(::iTCH::ClientRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .iTCH.ClientRequest.Value value = 3;
inline bool ClientRequest::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest::clear_value() {
  if (value_ != NULL) value_->::iTCH::ClientRequest_Value::Clear();
  clear_has_value();
}
inline const ::iTCH::ClientRequest_Value& ClientRequest::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::iTCH::ClientRequest_Value* ClientRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::iTCH::ClientRequest_Value;
  return value_;
}
inline ::iTCH::ClientRequest_Value* ClientRequest::release_value() {
  clear_has_value();
  ::iTCH::ClientRequest_Value* temp = value_;
  value_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Track

// required string name = 1;
inline bool Track::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Track::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Track::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Track::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Track::name() const {
  return *name_;
}
inline void Track::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Track::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Track::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Track::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string artist = 2;
inline bool Track::has_artist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Track::set_has_artist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Track::clear_has_artist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Track::clear_artist() {
  if (artist_ != &::google::protobuf::internal::kEmptyString) {
    artist_->clear();
  }
  clear_has_artist();
}
inline const ::std::string& Track::artist() const {
  return *artist_;
}
inline void Track::set_artist(const ::std::string& value) {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  artist_->assign(value);
}
inline void Track::set_artist(const char* value) {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  artist_->assign(value);
}
inline void Track::set_artist(const char* value, size_t size) {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  artist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_artist() {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  return artist_;
}
inline ::std::string* Track::release_artist() {
  clear_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = artist_;
    artist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string album = 3;
inline bool Track::has_album() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Track::set_has_album() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Track::clear_has_album() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Track::clear_album() {
  if (album_ != &::google::protobuf::internal::kEmptyString) {
    album_->clear();
  }
  clear_has_album();
}
inline const ::std::string& Track::album() const {
  return *album_;
}
inline void Track::set_album(const ::std::string& value) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void Track::set_album(const char* value) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void Track::set_album(const char* value, size_t size) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_album() {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  return album_;
}
inline ::std::string* Track::release_album() {
  clear_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = album_;
    album_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 duration = 4;
inline bool Track::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Track::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Track::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Track::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 Track::duration() const {
  return duration_;
}
inline void Track::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// required string genre = 5;
inline bool Track::has_genre() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Track::set_has_genre() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Track::clear_has_genre() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Track::clear_genre() {
  if (genre_ != &::google::protobuf::internal::kEmptyString) {
    genre_->clear();
  }
  clear_has_genre();
}
inline const ::std::string& Track::genre() const {
  return *genre_;
}
inline void Track::set_genre(const ::std::string& value) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void Track::set_genre(const char* value) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void Track::set_genre(const char* value, size_t size) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_genre() {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  return genre_;
}
inline ::std::string* Track::release_genre() {
  clear_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = genre_;
    genre_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 year = 6;
inline bool Track::has_year() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Track::set_has_year() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Track::clear_has_year() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Track::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 Track::year() const {
  return year_;
}
inline void Track::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
}

// optional uint32 bitrate = 7;
inline bool Track::has_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Track::set_has_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Track::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Track::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 Track::bitrate() const {
  return bitrate_;
}
inline void Track::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional uint32 sample_rate = 8;
inline bool Track::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Track::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Track::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Track::clear_sample_rate() {
  sample_rate_ = 0u;
  clear_has_sample_rate();
}
inline ::google::protobuf::uint32 Track::sample_rate() const {
  return sample_rate_;
}
inline void Track::set_sample_rate(::google::protobuf::uint32 value) {
  set_has_sample_rate();
  sample_rate_ = value;
}

// optional string comment = 9;
inline bool Track::has_comment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Track::set_has_comment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Track::clear_has_comment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Track::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Track::comment() const {
  return *comment_;
}
inline void Track::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Track::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Track::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Track::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string kind = 10;
inline bool Track::has_kind() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Track::set_has_kind() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Track::clear_has_kind() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Track::clear_kind() {
  if (kind_ != &::google::protobuf::internal::kEmptyString) {
    kind_->clear();
  }
  clear_has_kind();
}
inline const ::std::string& Track::kind() const {
  return *kind_;
}
inline void Track::set_kind(const ::std::string& value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void Track::set_kind(const char* value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void Track::set_kind(const char* value, size_t size) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_kind() {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  return kind_;
}
inline ::std::string* Track::release_kind() {
  clear_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kind_;
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerResponse_Value

// required .iTCH.ServerResponse.Value.Type type = 1;
inline bool ServerResponse_Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerResponse_Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerResponse_Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerResponse_Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::iTCH::ServerResponse_Value_Type ServerResponse_Value::type() const {
  return static_cast< ::iTCH::ServerResponse_Value_Type >(type_);
}
inline void ServerResponse_Value::set_type(::iTCH::ServerResponse_Value_Type value) {
  GOOGLE_DCHECK(::iTCH::ServerResponse_Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 volume = 2;
inline bool ServerResponse_Value::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerResponse_Value::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerResponse_Value::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerResponse_Value::clear_volume() {
  volume_ = 0u;
  clear_has_volume();
}
inline ::google::protobuf::uint32 ServerResponse_Value::volume() const {
  return volume_;
}
inline void ServerResponse_Value::set_volume(::google::protobuf::uint32 value) {
  set_has_volume();
  volume_ = value;
}

// optional bool mute = 3;
inline bool ServerResponse_Value::has_mute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerResponse_Value::set_has_mute() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerResponse_Value::clear_has_mute() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerResponse_Value::clear_mute() {
  mute_ = false;
  clear_has_mute();
}
inline bool ServerResponse_Value::mute() const {
  return mute_;
}
inline void ServerResponse_Value::set_mute(bool value) {
  set_has_mute();
  mute_ = value;
}

// optional uint32 position = 4;
inline bool ServerResponse_Value::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerResponse_Value::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerResponse_Value::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerResponse_Value::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 ServerResponse_Value::position() const {
  return position_;
}
inline void ServerResponse_Value::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional .iTCH.PlayerState state = 5;
inline bool ServerResponse_Value::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerResponse_Value::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerResponse_Value::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerResponse_Value::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline iTCH::PlayerState ServerResponse_Value::state() const {
  return static_cast< iTCH::PlayerState >(state_);
}
inline void ServerResponse_Value::set_state(iTCH::PlayerState value) {
  GOOGLE_DCHECK(iTCH::PlayerState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .iTCH.Track track = 6;
inline bool ServerResponse_Value::has_track() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerResponse_Value::set_has_track() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerResponse_Value::clear_has_track() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerResponse_Value::clear_track() {
  if (track_ != NULL) track_->::iTCH::Track::Clear();
  clear_has_track();
}
inline const ::iTCH::Track& ServerResponse_Value::track() const {
  return track_ != NULL ? *track_ : *default_instance_->track_;
}
inline ::iTCH::Track* ServerResponse_Value::mutable_track() {
  set_has_track();
  if (track_ == NULL) track_ = new ::iTCH::Track;
  return track_;
}
inline ::iTCH::Track* ServerResponse_Value::release_track() {
  clear_has_track();
  ::iTCH::Track* temp = track_;
  track_ = NULL;
  return temp;
}

// repeated .iTCH.Track playlist = 7;
inline int ServerResponse_Value::playlist_size() const {
  return playlist_.size();
}
inline void ServerResponse_Value::clear_playlist() {
  playlist_.Clear();
}
inline const ::iTCH::Track& ServerResponse_Value::playlist(int index) const {
  return playlist_.Get(index);
}
inline ::iTCH::Track* ServerResponse_Value::mutable_playlist(int index) {
  return playlist_.Mutable(index);
}
inline ::iTCH::Track* ServerResponse_Value::add_playlist() {
  return playlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::iTCH::Track >&
ServerResponse_Value::playlist() const {
  return playlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::iTCH::Track >*
ServerResponse_Value::mutable_playlist() {
  return &playlist_;
}

// -------------------------------------------------------------------

// ServerResponse

// required uint32 seqid = 1 [default = 0];
inline bool ServerResponse::has_seqid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerResponse::set_has_seqid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerResponse::clear_has_seqid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerResponse::clear_seqid() {
  seqid_ = 0u;
  clear_has_seqid();
}
inline ::google::protobuf::uint32 ServerResponse::seqid() const {
  return seqid_;
}
inline void ServerResponse::set_seqid(::google::protobuf::uint32 value) {
  set_has_seqid();
  seqid_ = value;
}

// required bool success = 2;
inline bool ServerResponse::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerResponse::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ServerResponse::success() const {
  return success_;
}
inline void ServerResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string error_message = 3;
inline bool ServerResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& ServerResponse::error_message() const {
  return *error_message_;
}
inline void ServerResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ServerResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ServerResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* ServerResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .iTCH.ServerResponse.Value value = 4;
inline bool ServerResponse::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerResponse::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerResponse::clear_value() {
  if (value_ != NULL) value_->::iTCH::ServerResponse_Value::Clear();
  clear_has_value();
}
inline const ::iTCH::ServerResponse_Value& ServerResponse::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::iTCH::ServerResponse_Value* ServerResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::iTCH::ServerResponse_Value;
  return value_;
}
inline ::iTCH::ServerResponse_Value* ServerResponse::release_value() {
  clear_has_value();
  ::iTCH::ServerResponse_Value* temp = value_;
  value_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace iTCH

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::Envelope_Type>() {
  return ::iTCH::Envelope_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ServerNotification_Type>() {
  return ::iTCH::ServerNotification_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ClientRequest_Value_Type>() {
  return ::iTCH::ClientRequest_Value_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ClientRequest_Type>() {
  return ::iTCH::ClientRequest_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ServerResponse_Value_Type>() {
  return ::iTCH::ServerResponse_Value_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< iTCH::Version>() {
  return iTCH::Version_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< iTCH::PlayerState>() {
  return iTCH::PlayerState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_iTCH_2eproto__INCLUDED
