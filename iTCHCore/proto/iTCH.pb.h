// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: iTCH.proto

#ifndef PROTOBUF_iTCH_2eproto__INCLUDED
#define PROTOBUF_iTCH_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
// @@protoc_insertion_point(includes)

namespace iTCH {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_iTCH_2eproto();
void protobuf_AssignDesc_iTCH_2eproto();
void protobuf_ShutdownFile_iTCH_2eproto();

class ServerNotification;
class ClientAck;
class ClientRequest;
class ClientRequest_Value;
class Track;
class ServerResponse;
class ServerResponse_Value;

enum ServerNotification_Notification {
  ServerNotification_Notification_VOLUMECHANGED = 0,
  ServerNotification_Notification_PLAYINGSTARTED = 1,
  ServerNotification_Notification_PLAYINGSTOPPED = 2,
  ServerNotification_Notification_TRACKINFOCHANGED = 3
};
bool ServerNotification_Notification_IsValid(int value);
const ServerNotification_Notification ServerNotification_Notification_Notification_MIN = ServerNotification_Notification_VOLUMECHANGED;
const ServerNotification_Notification ServerNotification_Notification_Notification_MAX = ServerNotification_Notification_TRACKINFOCHANGED;
const int ServerNotification_Notification_Notification_ARRAYSIZE = ServerNotification_Notification_Notification_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerNotification_Notification_descriptor();
inline const ::std::string& ServerNotification_Notification_Name(ServerNotification_Notification value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerNotification_Notification_descriptor(), value);
}
inline bool ServerNotification_Notification_Parse(
    const ::std::string& name, ServerNotification_Notification* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerNotification_Notification>(
    ServerNotification_Notification_descriptor(), name, value);
}
enum ClientRequest_Value_Type {
  ClientRequest_Value_Type_VOLUME = 0,
  ClientRequest_Value_Type_MUTE = 1,
  ClientRequest_Value_Type_POSITION = 2
};
bool ClientRequest_Value_Type_IsValid(int value);
const ClientRequest_Value_Type ClientRequest_Value_Type_Type_MIN = ClientRequest_Value_Type_VOLUME;
const ClientRequest_Value_Type ClientRequest_Value_Type_Type_MAX = ClientRequest_Value_Type_POSITION;
const int ClientRequest_Value_Type_Type_ARRAYSIZE = ClientRequest_Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientRequest_Value_Type_descriptor();
inline const ::std::string& ClientRequest_Value_Type_Name(ClientRequest_Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientRequest_Value_Type_descriptor(), value);
}
inline bool ClientRequest_Value_Type_Parse(
    const ::std::string& name, ClientRequest_Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientRequest_Value_Type>(
    ClientRequest_Value_Type_descriptor(), name, value);
}
enum ClientRequest_Action {
  ClientRequest_Action_BACKTRACK = 0,
  ClientRequest_Action_FASTFORWARD = 1,
  ClientRequest_Action_NEXTTRACK = 2,
  ClientRequest_Action_PAUSE = 3,
  ClientRequest_Action_PLAY = 4,
  ClientRequest_Action_PLAYPAUSE = 5,
  ClientRequest_Action_PREVIOUSTRACK = 6,
  ClientRequest_Action_RESUME = 7,
  ClientRequest_Action_REWIND = 8,
  ClientRequest_Action_STOP = 9,
  ClientRequest_Action_GET_SOUNDVOLUME = 10,
  ClientRequest_Action_PUT_SOUNDVOLUME = 11,
  ClientRequest_Action_GET_MUTE = 12,
  ClientRequest_Action_PUT_MUTE = 13,
  ClientRequest_Action_GET_PLAYERPOSITION = 14,
  ClientRequest_Action_PUT_PLAYERPOSITION = 15,
  ClientRequest_Action_GET_PLAYERSTATE = 16,
  ClientRequest_Action_GET_CURRENTTRACK = 17,
  ClientRequest_Action_GET_CURRENTPLAYLIST = 18
};
bool ClientRequest_Action_IsValid(int value);
const ClientRequest_Action ClientRequest_Action_Action_MIN = ClientRequest_Action_BACKTRACK;
const ClientRequest_Action ClientRequest_Action_Action_MAX = ClientRequest_Action_GET_CURRENTPLAYLIST;
const int ClientRequest_Action_Action_ARRAYSIZE = ClientRequest_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientRequest_Action_descriptor();
inline const ::std::string& ClientRequest_Action_Name(ClientRequest_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientRequest_Action_descriptor(), value);
}
inline bool ClientRequest_Action_Parse(
    const ::std::string& name, ClientRequest_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientRequest_Action>(
    ClientRequest_Action_descriptor(), name, value);
}
enum ServerResponse_Value_Type {
  ServerResponse_Value_Type_VOLUME = 0,
  ServerResponse_Value_Type_MUTE = 1,
  ServerResponse_Value_Type_POSITION = 2,
  ServerResponse_Value_Type_TRACK = 3
};
bool ServerResponse_Value_Type_IsValid(int value);
const ServerResponse_Value_Type ServerResponse_Value_Type_Type_MIN = ServerResponse_Value_Type_VOLUME;
const ServerResponse_Value_Type ServerResponse_Value_Type_Type_MAX = ServerResponse_Value_Type_TRACK;
const int ServerResponse_Value_Type_Type_ARRAYSIZE = ServerResponse_Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerResponse_Value_Type_descriptor();
inline const ::std::string& ServerResponse_Value_Type_Name(ServerResponse_Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerResponse_Value_Type_descriptor(), value);
}
inline bool ServerResponse_Value_Type_Parse(
    const ::std::string& name, ServerResponse_Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerResponse_Value_Type>(
    ServerResponse_Value_Type_descriptor(), name, value);
}
// ===================================================================

class ServerNotification : public ::google::protobuf::Message {
 public:
  ServerNotification();
  virtual ~ServerNotification();
  
  ServerNotification(const ServerNotification& from);
  
  inline ServerNotification& operator=(const ServerNotification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerNotification& default_instance();
  
  void Swap(ServerNotification* other);
  
  // implements Message ----------------------------------------------
  
  ServerNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerNotification& from);
  void MergeFrom(const ServerNotification& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerNotification_Notification Notification;
  static const Notification VOLUMECHANGED = ServerNotification_Notification_VOLUMECHANGED;
  static const Notification PLAYINGSTARTED = ServerNotification_Notification_PLAYINGSTARTED;
  static const Notification PLAYINGSTOPPED = ServerNotification_Notification_PLAYINGSTOPPED;
  static const Notification TRACKINFOCHANGED = ServerNotification_Notification_TRACKINFOCHANGED;
  static inline bool Notification_IsValid(int value) {
    return ServerNotification_Notification_IsValid(value);
  }
  static const Notification Notification_MIN =
    ServerNotification_Notification_Notification_MIN;
  static const Notification Notification_MAX =
    ServerNotification_Notification_Notification_MAX;
  static const int Notification_ARRAYSIZE =
    ServerNotification_Notification_Notification_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Notification_descriptor() {
    return ServerNotification_Notification_descriptor();
  }
  static inline const ::std::string& Notification_Name(Notification value) {
    return ServerNotification_Notification_Name(value);
  }
  static inline bool Notification_Parse(const ::std::string& name,
      Notification* value) {
    return ServerNotification_Notification_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 seqid = 1;
  inline bool has_seqid() const;
  inline void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  inline ::google::protobuf::uint32 seqid() const;
  inline void set_seqid(::google::protobuf::uint32 value);
  
  // required .iTCH.ServerNotification.Notification notification = 2;
  inline bool has_notification() const;
  inline void clear_notification();
  static const int kNotificationFieldNumber = 2;
  inline ::iTCH::ServerNotification_Notification notification() const;
  inline void set_notification(::iTCH::ServerNotification_Notification value);
  
  // @@protoc_insertion_point(class_scope:iTCH.ServerNotification)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 seqid_;
  int notification_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ServerNotification* default_instance_;
};
// -------------------------------------------------------------------

class ClientAck : public ::google::protobuf::Message {
 public:
  ClientAck();
  virtual ~ClientAck();
  
  ClientAck(const ClientAck& from);
  
  inline ClientAck& operator=(const ClientAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAck& default_instance();
  
  void Swap(ClientAck* other);
  
  // implements Message ----------------------------------------------
  
  ClientAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientAck& from);
  void MergeFrom(const ClientAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 seqid = 1;
  inline bool has_seqid() const;
  inline void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  inline ::google::protobuf::uint32 seqid() const;
  inline void set_seqid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:iTCH.ClientAck)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 seqid_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ClientAck* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_Value : public ::google::protobuf::Message {
 public:
  ClientRequest_Value();
  virtual ~ClientRequest_Value();
  
  ClientRequest_Value(const ClientRequest_Value& from);
  
  inline ClientRequest_Value& operator=(const ClientRequest_Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_Value& default_instance();
  
  void Swap(ClientRequest_Value* other);
  
  // implements Message ----------------------------------------------
  
  ClientRequest_Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_Value& from);
  void MergeFrom(const ClientRequest_Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientRequest_Value_Type Type;
  static const Type VOLUME = ClientRequest_Value_Type_VOLUME;
  static const Type MUTE = ClientRequest_Value_Type_MUTE;
  static const Type POSITION = ClientRequest_Value_Type_POSITION;
  static inline bool Type_IsValid(int value) {
    return ClientRequest_Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientRequest_Value_Type_Type_MIN;
  static const Type Type_MAX =
    ClientRequest_Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientRequest_Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientRequest_Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientRequest_Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientRequest_Value_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.ClientRequest.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::iTCH::ClientRequest_Value_Type type() const;
  inline void set_type(::iTCH::ClientRequest_Value_Type value);
  
  // optional uint32 volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline ::google::protobuf::uint32 volume() const;
  inline void set_volume(::google::protobuf::uint32 value);
  
  // optional bool mute = 3;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 3;
  inline bool mute() const;
  inline void set_mute(bool value);
  
  // optional uint32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:iTCH.ClientRequest.Value)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::google::protobuf::uint32 volume_;
  bool mute_;
  ::google::protobuf::uint32 position_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ClientRequest_Value* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message {
 public:
  ClientRequest();
  virtual ~ClientRequest();
  
  ClientRequest(const ClientRequest& from);
  
  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();
  
  void Swap(ClientRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientRequest_Value Value;
  
  typedef ClientRequest_Action Action;
  static const Action BACKTRACK = ClientRequest_Action_BACKTRACK;
  static const Action FASTFORWARD = ClientRequest_Action_FASTFORWARD;
  static const Action NEXTTRACK = ClientRequest_Action_NEXTTRACK;
  static const Action PAUSE = ClientRequest_Action_PAUSE;
  static const Action PLAY = ClientRequest_Action_PLAY;
  static const Action PLAYPAUSE = ClientRequest_Action_PLAYPAUSE;
  static const Action PREVIOUSTRACK = ClientRequest_Action_PREVIOUSTRACK;
  static const Action RESUME = ClientRequest_Action_RESUME;
  static const Action REWIND = ClientRequest_Action_REWIND;
  static const Action STOP = ClientRequest_Action_STOP;
  static const Action GET_SOUNDVOLUME = ClientRequest_Action_GET_SOUNDVOLUME;
  static const Action PUT_SOUNDVOLUME = ClientRequest_Action_PUT_SOUNDVOLUME;
  static const Action GET_MUTE = ClientRequest_Action_GET_MUTE;
  static const Action PUT_MUTE = ClientRequest_Action_PUT_MUTE;
  static const Action GET_PLAYERPOSITION = ClientRequest_Action_GET_PLAYERPOSITION;
  static const Action PUT_PLAYERPOSITION = ClientRequest_Action_PUT_PLAYERPOSITION;
  static const Action GET_PLAYERSTATE = ClientRequest_Action_GET_PLAYERSTATE;
  static const Action GET_CURRENTTRACK = ClientRequest_Action_GET_CURRENTTRACK;
  static const Action GET_CURRENTPLAYLIST = ClientRequest_Action_GET_CURRENTPLAYLIST;
  static inline bool Action_IsValid(int value) {
    return ClientRequest_Action_IsValid(value);
  }
  static const Action Action_MIN =
    ClientRequest_Action_Action_MIN;
  static const Action Action_MAX =
    ClientRequest_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    ClientRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return ClientRequest_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return ClientRequest_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return ClientRequest_Action_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 seqid = 1;
  inline bool has_seqid() const;
  inline void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  inline ::google::protobuf::uint32 seqid() const;
  inline void set_seqid(::google::protobuf::uint32 value);
  
  // required .iTCH.ClientRequest.Action action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::iTCH::ClientRequest_Action action() const;
  inline void set_action(::iTCH::ClientRequest_Action value);
  
  // optional .iTCH.ClientRequest.Value value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::iTCH::ClientRequest_Value& value() const;
  inline ::iTCH::ClientRequest_Value* mutable_value();
  
  // @@protoc_insertion_point(class_scope:iTCH.ClientRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 seqid_;
  int action_;
  ::iTCH::ClientRequest_Value* value_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class Track : public ::google::protobuf::Message {
 public:
  Track();
  virtual ~Track();
  
  Track(const Track& from);
  
  inline Track& operator=(const Track& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Track& default_instance();
  
  void Swap(Track* other);
  
  // implements Message ----------------------------------------------
  
  Track* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Track& from);
  void MergeFrom(const Track& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string artist = 2;
  inline bool has_artist() const;
  inline void clear_artist();
  static const int kArtistFieldNumber = 2;
  inline const ::std::string& artist() const;
  inline void set_artist(const ::std::string& value);
  inline void set_artist(const char* value);
  inline void set_artist(const char* value, size_t size);
  inline ::std::string* mutable_artist();
  
  // required string album = 3;
  inline bool has_album() const;
  inline void clear_album();
  static const int kAlbumFieldNumber = 3;
  inline const ::std::string& album() const;
  inline void set_album(const ::std::string& value);
  inline void set_album(const char* value);
  inline void set_album(const char* value, size_t size);
  inline ::std::string* mutable_album();
  
  // required uint32 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);
  
  // required string genre = 5;
  inline bool has_genre() const;
  inline void clear_genre();
  static const int kGenreFieldNumber = 5;
  inline const ::std::string& genre() const;
  inline void set_genre(const ::std::string& value);
  inline void set_genre(const char* value);
  inline void set_genre(const char* value, size_t size);
  inline ::std::string* mutable_genre();
  
  // required uint32 year = 6;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 6;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);
  
  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);
  
  // optional uint32 sample_rate = 8;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 8;
  inline ::google::protobuf::uint32 sample_rate() const;
  inline void set_sample_rate(::google::protobuf::uint32 value);
  
  // optional string comment = 9;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 9;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  
  // optional string kind = 10;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 10;
  inline const ::std::string& kind() const;
  inline void set_kind(const ::std::string& value);
  inline void set_kind(const char* value);
  inline void set_kind(const char* value, size_t size);
  inline ::std::string* mutable_kind();
  
  // @@protoc_insertion_point(class_scope:iTCH.Track)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* artist_;
  static const ::std::string _default_artist_;
  ::std::string* album_;
  static const ::std::string _default_album_;
  ::google::protobuf::uint32 duration_;
  ::std::string* genre_;
  static const ::std::string _default_genre_;
  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::uint32 sample_rate_;
  ::std::string* comment_;
  static const ::std::string _default_comment_;
  ::std::string* kind_;
  static const ::std::string _default_kind_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Track* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse_Value : public ::google::protobuf::Message {
 public:
  ServerResponse_Value();
  virtual ~ServerResponse_Value();
  
  ServerResponse_Value(const ServerResponse_Value& from);
  
  inline ServerResponse_Value& operator=(const ServerResponse_Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse_Value& default_instance();
  
  void Swap(ServerResponse_Value* other);
  
  // implements Message ----------------------------------------------
  
  ServerResponse_Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse_Value& from);
  void MergeFrom(const ServerResponse_Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerResponse_Value_Type Type;
  static const Type VOLUME = ServerResponse_Value_Type_VOLUME;
  static const Type MUTE = ServerResponse_Value_Type_MUTE;
  static const Type POSITION = ServerResponse_Value_Type_POSITION;
  static const Type TRACK = ServerResponse_Value_Type_TRACK;
  static inline bool Type_IsValid(int value) {
    return ServerResponse_Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ServerResponse_Value_Type_Type_MIN;
  static const Type Type_MAX =
    ServerResponse_Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ServerResponse_Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ServerResponse_Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ServerResponse_Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ServerResponse_Value_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .iTCH.ServerResponse.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::iTCH::ServerResponse_Value_Type type() const;
  inline void set_type(::iTCH::ServerResponse_Value_Type value);
  
  // optional uint32 volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline ::google::protobuf::uint32 volume() const;
  inline void set_volume(::google::protobuf::uint32 value);
  
  // optional bool mute = 3;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 3;
  inline bool mute() const;
  inline void set_mute(bool value);
  
  // optional uint32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);
  
  // optional .iTCH.Track track = 5;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 5;
  inline const ::iTCH::Track& track() const;
  inline ::iTCH::Track* mutable_track();
  
  // @@protoc_insertion_point(class_scope:iTCH.ServerResponse.Value)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::google::protobuf::uint32 volume_;
  bool mute_;
  ::google::protobuf::uint32 position_;
  ::iTCH::Track* track_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ServerResponse_Value* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message {
 public:
  ServerResponse();
  virtual ~ServerResponse();
  
  ServerResponse(const ServerResponse& from);
  
  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();
  
  void Swap(ServerResponse* other);
  
  // implements Message ----------------------------------------------
  
  ServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerResponse_Value Value;
  
  // accessors -------------------------------------------------------
  
  // required uint32 seqid = 1;
  inline bool has_seqid() const;
  inline void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  inline ::google::protobuf::uint32 seqid() const;
  inline void set_seqid(::google::protobuf::uint32 value);
  
  // optional .iTCH.ServerResponse.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::iTCH::ServerResponse_Value& value() const;
  inline ::iTCH::ServerResponse_Value* mutable_value();
  
  // @@protoc_insertion_point(class_scope:iTCH.ServerResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 seqid_;
  ::iTCH::ServerResponse_Value* value_;
  friend void  protobuf_AddDesc_iTCH_2eproto();
  friend void protobuf_AssignDesc_iTCH_2eproto();
  friend void protobuf_ShutdownFile_iTCH_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ServerResponse* default_instance_;
};
// ===================================================================

class NotificationService_Stub;

class NotificationService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline NotificationService() {};
 public:
  virtual ~NotificationService();
  
  typedef NotificationService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void Notify(::google::protobuf::RpcController* controller,
                       const ::iTCH::ServerNotification* request,
                       ::iTCH::ClientAck* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NotificationService);
};

class NotificationService_Stub : public NotificationService {
 public:
  NotificationService_Stub(::google::protobuf::RpcChannel* channel);
  NotificationService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~NotificationService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements NotificationService ------------------------------------------
  
  void Notify(::google::protobuf::RpcController* controller,
                       const ::iTCH::ServerNotification* request,
                       ::iTCH::ClientAck* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NotificationService_Stub);
};


// -------------------------------------------------------------------

class RequestService_Stub;

class RequestService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RequestService() {};
 public:
  virtual ~RequestService();
  
  typedef RequestService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void Request(::google::protobuf::RpcController* controller,
                       const ::iTCH::ClientRequest* request,
                       ::iTCH::ServerResponse* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RequestService);
};

class RequestService_Stub : public RequestService {
 public:
  RequestService_Stub(::google::protobuf::RpcChannel* channel);
  RequestService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RequestService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements RequestService ------------------------------------------
  
  void Request(::google::protobuf::RpcController* controller,
                       const ::iTCH::ClientRequest* request,
                       ::iTCH::ServerResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RequestService_Stub);
};


// ===================================================================


// ===================================================================

// ServerNotification

// required uint32 seqid = 1;
inline bool ServerNotification::has_seqid() const {
  return _has_bit(0);
}
inline void ServerNotification::clear_seqid() {
  seqid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ServerNotification::seqid() const {
  return seqid_;
}
inline void ServerNotification::set_seqid(::google::protobuf::uint32 value) {
  _set_bit(0);
  seqid_ = value;
}

// required .iTCH.ServerNotification.Notification notification = 2;
inline bool ServerNotification::has_notification() const {
  return _has_bit(1);
}
inline void ServerNotification::clear_notification() {
  notification_ = 0;
  _clear_bit(1);
}
inline ::iTCH::ServerNotification_Notification ServerNotification::notification() const {
  return static_cast< ::iTCH::ServerNotification_Notification >(notification_);
}
inline void ServerNotification::set_notification(::iTCH::ServerNotification_Notification value) {
  GOOGLE_DCHECK(::iTCH::ServerNotification_Notification_IsValid(value));
  _set_bit(1);
  notification_ = value;
}

// -------------------------------------------------------------------

// ClientAck

// required uint32 seqid = 1;
inline bool ClientAck::has_seqid() const {
  return _has_bit(0);
}
inline void ClientAck::clear_seqid() {
  seqid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ClientAck::seqid() const {
  return seqid_;
}
inline void ClientAck::set_seqid(::google::protobuf::uint32 value) {
  _set_bit(0);
  seqid_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_Value

// required .iTCH.ClientRequest.Value.Type type = 1;
inline bool ClientRequest_Value::has_type() const {
  return _has_bit(0);
}
inline void ClientRequest_Value::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::iTCH::ClientRequest_Value_Type ClientRequest_Value::type() const {
  return static_cast< ::iTCH::ClientRequest_Value_Type >(type_);
}
inline void ClientRequest_Value::set_type(::iTCH::ClientRequest_Value_Type value) {
  GOOGLE_DCHECK(::iTCH::ClientRequest_Value_Type_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional uint32 volume = 2;
inline bool ClientRequest_Value::has_volume() const {
  return _has_bit(1);
}
inline void ClientRequest_Value::clear_volume() {
  volume_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 ClientRequest_Value::volume() const {
  return volume_;
}
inline void ClientRequest_Value::set_volume(::google::protobuf::uint32 value) {
  _set_bit(1);
  volume_ = value;
}

// optional bool mute = 3;
inline bool ClientRequest_Value::has_mute() const {
  return _has_bit(2);
}
inline void ClientRequest_Value::clear_mute() {
  mute_ = false;
  _clear_bit(2);
}
inline bool ClientRequest_Value::mute() const {
  return mute_;
}
inline void ClientRequest_Value::set_mute(bool value) {
  _set_bit(2);
  mute_ = value;
}

// optional uint32 position = 4;
inline bool ClientRequest_Value::has_position() const {
  return _has_bit(3);
}
inline void ClientRequest_Value::clear_position() {
  position_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 ClientRequest_Value::position() const {
  return position_;
}
inline void ClientRequest_Value::set_position(::google::protobuf::uint32 value) {
  _set_bit(3);
  position_ = value;
}

// -------------------------------------------------------------------

// ClientRequest

// required uint32 seqid = 1;
inline bool ClientRequest::has_seqid() const {
  return _has_bit(0);
}
inline void ClientRequest::clear_seqid() {
  seqid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ClientRequest::seqid() const {
  return seqid_;
}
inline void ClientRequest::set_seqid(::google::protobuf::uint32 value) {
  _set_bit(0);
  seqid_ = value;
}

// required .iTCH.ClientRequest.Action action = 2;
inline bool ClientRequest::has_action() const {
  return _has_bit(1);
}
inline void ClientRequest::clear_action() {
  action_ = 0;
  _clear_bit(1);
}
inline ::iTCH::ClientRequest_Action ClientRequest::action() const {
  return static_cast< ::iTCH::ClientRequest_Action >(action_);
}
inline void ClientRequest::set_action(::iTCH::ClientRequest_Action value) {
  GOOGLE_DCHECK(::iTCH::ClientRequest_Action_IsValid(value));
  _set_bit(1);
  action_ = value;
}

// optional .iTCH.ClientRequest.Value value = 3;
inline bool ClientRequest::has_value() const {
  return _has_bit(2);
}
inline void ClientRequest::clear_value() {
  if (value_ != NULL) value_->::iTCH::ClientRequest_Value::Clear();
  _clear_bit(2);
}
inline const ::iTCH::ClientRequest_Value& ClientRequest::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::iTCH::ClientRequest_Value* ClientRequest::mutable_value() {
  _set_bit(2);
  if (value_ == NULL) value_ = new ::iTCH::ClientRequest_Value;
  return value_;
}

// -------------------------------------------------------------------

// Track

// required string name = 1;
inline bool Track::has_name() const {
  return _has_bit(0);
}
inline void Track::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Track::name() const {
  return *name_;
}
inline void Track::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Track::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Track::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string artist = 2;
inline bool Track::has_artist() const {
  return _has_bit(1);
}
inline void Track::clear_artist() {
  if (artist_ != &_default_artist_) {
    artist_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Track::artist() const {
  return *artist_;
}
inline void Track::set_artist(const ::std::string& value) {
  _set_bit(1);
  if (artist_ == &_default_artist_) {
    artist_ = new ::std::string;
  }
  artist_->assign(value);
}
inline void Track::set_artist(const char* value) {
  _set_bit(1);
  if (artist_ == &_default_artist_) {
    artist_ = new ::std::string;
  }
  artist_->assign(value);
}
inline void Track::set_artist(const char* value, size_t size) {
  _set_bit(1);
  if (artist_ == &_default_artist_) {
    artist_ = new ::std::string;
  }
  artist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_artist() {
  _set_bit(1);
  if (artist_ == &_default_artist_) {
    artist_ = new ::std::string;
  }
  return artist_;
}

// required string album = 3;
inline bool Track::has_album() const {
  return _has_bit(2);
}
inline void Track::clear_album() {
  if (album_ != &_default_album_) {
    album_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Track::album() const {
  return *album_;
}
inline void Track::set_album(const ::std::string& value) {
  _set_bit(2);
  if (album_ == &_default_album_) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void Track::set_album(const char* value) {
  _set_bit(2);
  if (album_ == &_default_album_) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void Track::set_album(const char* value, size_t size) {
  _set_bit(2);
  if (album_ == &_default_album_) {
    album_ = new ::std::string;
  }
  album_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_album() {
  _set_bit(2);
  if (album_ == &_default_album_) {
    album_ = new ::std::string;
  }
  return album_;
}

// required uint32 duration = 4;
inline bool Track::has_duration() const {
  return _has_bit(3);
}
inline void Track::clear_duration() {
  duration_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 Track::duration() const {
  return duration_;
}
inline void Track::set_duration(::google::protobuf::uint32 value) {
  _set_bit(3);
  duration_ = value;
}

// required string genre = 5;
inline bool Track::has_genre() const {
  return _has_bit(4);
}
inline void Track::clear_genre() {
  if (genre_ != &_default_genre_) {
    genre_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Track::genre() const {
  return *genre_;
}
inline void Track::set_genre(const ::std::string& value) {
  _set_bit(4);
  if (genre_ == &_default_genre_) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void Track::set_genre(const char* value) {
  _set_bit(4);
  if (genre_ == &_default_genre_) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void Track::set_genre(const char* value, size_t size) {
  _set_bit(4);
  if (genre_ == &_default_genre_) {
    genre_ = new ::std::string;
  }
  genre_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_genre() {
  _set_bit(4);
  if (genre_ == &_default_genre_) {
    genre_ = new ::std::string;
  }
  return genre_;
}

// required uint32 year = 6;
inline bool Track::has_year() const {
  return _has_bit(5);
}
inline void Track::clear_year() {
  year_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 Track::year() const {
  return year_;
}
inline void Track::set_year(::google::protobuf::uint32 value) {
  _set_bit(5);
  year_ = value;
}

// optional uint32 bitrate = 7;
inline bool Track::has_bitrate() const {
  return _has_bit(6);
}
inline void Track::clear_bitrate() {
  bitrate_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 Track::bitrate() const {
  return bitrate_;
}
inline void Track::set_bitrate(::google::protobuf::uint32 value) {
  _set_bit(6);
  bitrate_ = value;
}

// optional uint32 sample_rate = 8;
inline bool Track::has_sample_rate() const {
  return _has_bit(7);
}
inline void Track::clear_sample_rate() {
  sample_rate_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 Track::sample_rate() const {
  return sample_rate_;
}
inline void Track::set_sample_rate(::google::protobuf::uint32 value) {
  _set_bit(7);
  sample_rate_ = value;
}

// optional string comment = 9;
inline bool Track::has_comment() const {
  return _has_bit(8);
}
inline void Track::clear_comment() {
  if (comment_ != &_default_comment_) {
    comment_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& Track::comment() const {
  return *comment_;
}
inline void Track::set_comment(const ::std::string& value) {
  _set_bit(8);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Track::set_comment(const char* value) {
  _set_bit(8);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Track::set_comment(const char* value, size_t size) {
  _set_bit(8);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_comment() {
  _set_bit(8);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  return comment_;
}

// optional string kind = 10;
inline bool Track::has_kind() const {
  return _has_bit(9);
}
inline void Track::clear_kind() {
  if (kind_ != &_default_kind_) {
    kind_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& Track::kind() const {
  return *kind_;
}
inline void Track::set_kind(const ::std::string& value) {
  _set_bit(9);
  if (kind_ == &_default_kind_) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void Track::set_kind(const char* value) {
  _set_bit(9);
  if (kind_ == &_default_kind_) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void Track::set_kind(const char* value, size_t size) {
  _set_bit(9);
  if (kind_ == &_default_kind_) {
    kind_ = new ::std::string;
  }
  kind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_kind() {
  _set_bit(9);
  if (kind_ == &_default_kind_) {
    kind_ = new ::std::string;
  }
  return kind_;
}

// -------------------------------------------------------------------

// ServerResponse_Value

// required .iTCH.ServerResponse.Value.Type type = 1;
inline bool ServerResponse_Value::has_type() const {
  return _has_bit(0);
}
inline void ServerResponse_Value::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::iTCH::ServerResponse_Value_Type ServerResponse_Value::type() const {
  return static_cast< ::iTCH::ServerResponse_Value_Type >(type_);
}
inline void ServerResponse_Value::set_type(::iTCH::ServerResponse_Value_Type value) {
  GOOGLE_DCHECK(::iTCH::ServerResponse_Value_Type_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional uint32 volume = 2;
inline bool ServerResponse_Value::has_volume() const {
  return _has_bit(1);
}
inline void ServerResponse_Value::clear_volume() {
  volume_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 ServerResponse_Value::volume() const {
  return volume_;
}
inline void ServerResponse_Value::set_volume(::google::protobuf::uint32 value) {
  _set_bit(1);
  volume_ = value;
}

// optional bool mute = 3;
inline bool ServerResponse_Value::has_mute() const {
  return _has_bit(2);
}
inline void ServerResponse_Value::clear_mute() {
  mute_ = false;
  _clear_bit(2);
}
inline bool ServerResponse_Value::mute() const {
  return mute_;
}
inline void ServerResponse_Value::set_mute(bool value) {
  _set_bit(2);
  mute_ = value;
}

// optional uint32 position = 4;
inline bool ServerResponse_Value::has_position() const {
  return _has_bit(3);
}
inline void ServerResponse_Value::clear_position() {
  position_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 ServerResponse_Value::position() const {
  return position_;
}
inline void ServerResponse_Value::set_position(::google::protobuf::uint32 value) {
  _set_bit(3);
  position_ = value;
}

// optional .iTCH.Track track = 5;
inline bool ServerResponse_Value::has_track() const {
  return _has_bit(4);
}
inline void ServerResponse_Value::clear_track() {
  if (track_ != NULL) track_->::iTCH::Track::Clear();
  _clear_bit(4);
}
inline const ::iTCH::Track& ServerResponse_Value::track() const {
  return track_ != NULL ? *track_ : *default_instance_->track_;
}
inline ::iTCH::Track* ServerResponse_Value::mutable_track() {
  _set_bit(4);
  if (track_ == NULL) track_ = new ::iTCH::Track;
  return track_;
}

// -------------------------------------------------------------------

// ServerResponse

// required uint32 seqid = 1;
inline bool ServerResponse::has_seqid() const {
  return _has_bit(0);
}
inline void ServerResponse::clear_seqid() {
  seqid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ServerResponse::seqid() const {
  return seqid_;
}
inline void ServerResponse::set_seqid(::google::protobuf::uint32 value) {
  _set_bit(0);
  seqid_ = value;
}

// optional .iTCH.ServerResponse.Value value = 2;
inline bool ServerResponse::has_value() const {
  return _has_bit(1);
}
inline void ServerResponse::clear_value() {
  if (value_ != NULL) value_->::iTCH::ServerResponse_Value::Clear();
  _clear_bit(1);
}
inline const ::iTCH::ServerResponse_Value& ServerResponse::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::iTCH::ServerResponse_Value* ServerResponse::mutable_value() {
  _set_bit(1);
  if (value_ == NULL) value_ = new ::iTCH::ServerResponse_Value;
  return value_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace iTCH

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ServerNotification_Notification>() {
  return ::iTCH::ServerNotification_Notification_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ClientRequest_Value_Type>() {
  return ::iTCH::ClientRequest_Value_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ClientRequest_Action>() {
  return ::iTCH::ClientRequest_Action_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iTCH::ServerResponse_Value_Type>() {
  return ::iTCH::ServerResponse_Value_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_iTCH_2eproto__INCLUDED
